initSidebarItems({"constant":[["MSEC_PER_SEC",""],["NSEC_PER_MSEC",""],["STR_CONF_CHANGE_ADDLEARNER_NODE",""],["STR_CONF_CHANGE_ADD_NODE",""],["STR_CONF_CHANGE_REMOVE_NODE",""],["TIMESPEC_NSEC_MASK",""],["TIMESPEC_NSEC_SHIFT",""],["TIMESPEC_SEC_SHIFT",""]],"enum":[["LeaseState",""]],"fn":[["build_key_range",""],["check_key_in_region","Check if key in region range [`start_key`, `end_key`)."],["check_key_in_region_exclusive","Check if key in region range (`start_key`, `end_key`)."],["check_key_in_region_inclusive","Check if key in region range [`start_key`, `end_key`]."],["check_peer_id",""],["check_region_epoch",""],["check_store_id",""],["check_term",""],["compare_region_epoch",""],["conf_change_type_str",""],["conf_state_from_region",""],["find_peer",""],["find_peer_mut",""],["integration_on_half_fail_quorum_fn",""],["is_epoch_stale",""],["is_first_vote_msg","`is_first_vote_msg` checks `msg` is the first vote (or prevote) message or not. It's used for when the message is received but there is no such region in `Store::region_peers` and the region overlaps with others. In this case we should put `msg` into `pending_votes` instead of create the peer."],["is_initial_msg","`is_initial_msg` checks whether the `msg` can be used to initialize a new peer or not."],["is_learner",""],["is_region_initialized",""],["is_sibling_regions","Check if two regions are sibling."],["is_vote_msg",""],["new_learner_peer",""],["new_peer",""],["parse_data_at","Parse data of entry `index`."],["region_on_same_stores","Check if replicas of two regions are on the same stores."],["remove_peer",""],["timespec_to_u64","Convert Timespec to u64. It's millisecond precision and covers a range of about 571232829 years in total."],["u64_to_timespec","Convert Timespec to u64."]],"static":[["NORMAL_REQ_CHECK_CONF_VER",""],["NORMAL_REQ_CHECK_VER","WARNING: `NORMAL_REQ_CHECK_VER` and `NORMAL_REQ_CHECK_CONF_VER` MUST NOT be changed. The reason is the same as `ADMIN_CMD_EPOCH_MAP`."]],"struct":[["ADMIN_CMD_EPOCH_MAP","WARNING: the existing settings in `ADMIN_CMD_EPOCH_MAP` MUST NOT be changed!!! Changing any admin cmd's `AdminCmdEpochState` or the epoch-change behavior during applying will break upgrade compatibility and correctness dependency of `CmdEpochChecker`. Please remember it is very difficult to fix the issues arising from not following this rule."],["AdminCmdEpochState",""],["KeysInfoFormatter",""],["Lease","Lease records an expired time, for examining the current moment is in lease or not. It's dedicated to the Raft leader lease mechanism, contains either state of   1. Suspect Timestamp      A suspicious leader lease timestamp, which marks the leader may still hold or lose      its lease until the clock time goes over this timestamp.   2. Valid Timestamp      A valid leader lease timestamp, which marks the leader holds the lease for now.      The lease is valid until the clock time goes over this timestamp."],["PerfContextStatistics",""],["RemoteLease","A remote lease, it can only be derived by `Lease`. It will be sent to the local read thread, so name it remote. If Lease expires, the remote must expire too."]]});