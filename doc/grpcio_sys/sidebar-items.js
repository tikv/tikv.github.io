initSidebarItems({"constant":[["GRPC_ALLOW_EXCEPTIONS",""],["GRPC_ALLOW_GPR_SLICE_FUNCTIONS",""],["GRPC_ARES",""],["GRPC_ARG_ALLOW_REUSEPORT",""],["GRPC_ARG_CHANNEL_ID",""],["GRPC_ARG_CHANNEL_POOL_DOMAIN",""],["GRPC_ARG_CLIENT_IDLE_TIMEOUT_MS",""],["GRPC_ARG_DEFAULT_AUTHORITY",""],["GRPC_ARG_DISABLE_CLIENT_AUTHORITY_FILTER",""],["GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS",""],["GRPC_ARG_DNS_ENABLE_SRV_QUERIES",""],["GRPC_ARG_DNS_MIN_TIME_BETWEEN_RESOLUTIONS_MS",""],["GRPC_ARG_ENABLE_CENSUS",""],["GRPC_ARG_ENABLE_CHANNELZ",""],["GRPC_ARG_ENABLE_DEADLINE_CHECKS",""],["GRPC_ARG_ENABLE_HTTP_PROXY",""],["GRPC_ARG_ENABLE_LOAD_REPORTING",""],["GRPC_ARG_ENABLE_PER_MESSAGE_COMPRESSION",""],["GRPC_ARG_ENABLE_PER_MESSAGE_DECOMPRESSION",""],["GRPC_ARG_ENABLE_RETRIES",""],["GRPC_ARG_EXPAND_WILDCARD_ADDRS",""],["GRPC_ARG_GRPCLB_CALL_TIMEOUT_MS",""],["GRPC_ARG_GRPCLB_FALLBACK_TIMEOUT_MS",""],["GRPC_ARG_HTTP2_BDP_PROBE",""],["GRPC_ARG_HTTP2_ENABLE_TRUE_BINARY",""],["GRPC_ARG_HTTP2_HPACK_TABLE_SIZE_DECODER",""],["GRPC_ARG_HTTP2_HPACK_TABLE_SIZE_ENCODER",""],["GRPC_ARG_HTTP2_INITIAL_SEQUENCE_NUMBER",""],["GRPC_ARG_HTTP2_MAX_FRAME_SIZE",""],["GRPC_ARG_HTTP2_MAX_PINGS_WITHOUT_DATA",""],["GRPC_ARG_HTTP2_MAX_PING_STRIKES",""],["GRPC_ARG_HTTP2_MIN_RECV_PING_INTERVAL_WITHOUT_DATA_MS",""],["GRPC_ARG_HTTP2_MIN_SENT_PING_INTERVAL_WITHOUT_DATA_MS",""],["GRPC_ARG_HTTP2_SCHEME",""],["GRPC_ARG_HTTP2_STREAM_LOOKAHEAD_BYTES",""],["GRPC_ARG_HTTP2_WRITE_BUFFER_SIZE",""],["GRPC_ARG_INHIBIT_HEALTH_CHECKING",""],["GRPC_ARG_INITIAL_RECONNECT_BACKOFF_MS",""],["GRPC_ARG_KEEPALIVE_PERMIT_WITHOUT_CALLS",""],["GRPC_ARG_KEEPALIVE_TIMEOUT_MS",""],["GRPC_ARG_KEEPALIVE_TIME_MS",""],["GRPC_ARG_LB_POLICY_NAME",""],["GRPC_ARG_MAX_CHANNEL_TRACE_EVENT_MEMORY_PER_NODE",""],["GRPC_ARG_MAX_CONCURRENT_STREAMS",""],["GRPC_ARG_MAX_CONNECTION_AGE_GRACE_MS",""],["GRPC_ARG_MAX_CONNECTION_AGE_MS",""],["GRPC_ARG_MAX_CONNECTION_IDLE_MS",""],["GRPC_ARG_MAX_MESSAGE_LENGTH",""],["GRPC_ARG_MAX_METADATA_SIZE",""],["GRPC_ARG_MAX_RECEIVE_MESSAGE_LENGTH",""],["GRPC_ARG_MAX_RECONNECT_BACKOFF_MS",""],["GRPC_ARG_MAX_SEND_MESSAGE_LENGTH",""],["GRPC_ARG_MINIMAL_STACK",""],["GRPC_ARG_MIN_RECONNECT_BACKOFF_MS",""],["GRPC_ARG_MOBILE_LOG_CONTEXT",""],["GRPC_ARG_OPTIMIZATION_TARGET",""],["GRPC_ARG_PER_RPC_RETRY_BUFFER_SIZE",""],["GRPC_ARG_PRIMARY_USER_AGENT_STRING",""],["GRPC_ARG_PRIORITY_FAILOVER_TIMEOUT_MS",""],["GRPC_ARG_RESOURCE_QUOTA",""],["GRPC_ARG_SECONDARY_USER_AGENT_STRING",""],["GRPC_ARG_SERVER_HANDSHAKE_TIMEOUT_MS",""],["GRPC_ARG_SERVICE_CONFIG",""],["GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION",""],["GRPC_ARG_SOCKET_FACTORY",""],["GRPC_ARG_SOCKET_MUTATOR",""],["GRPC_ARG_SURFACE_USER_AGENT",""],["GRPC_ARG_TCP_MAX_READ_CHUNK_SIZE",""],["GRPC_ARG_TCP_MIN_READ_CHUNK_SIZE",""],["GRPC_ARG_TCP_READ_CHUNK_SIZE",""],["GRPC_ARG_TCP_TX_ZEROCOPY_ENABLED",""],["GRPC_ARG_TCP_TX_ZEROCOPY_MAX_SIMULT_SENDS",""],["GRPC_ARG_TCP_TX_ZEROCOPY_SEND_BYTES_THRESHOLD",""],["GRPC_ARG_TSI_MAX_FRAME_SIZE",""],["GRPC_ARG_USE_CRONET_PACKET_COALESCING",""],["GRPC_ARG_USE_LOCAL_SUBCHANNEL_POOL",""],["GRPC_ARG_WORKAROUND_CRONET_COMPRESSION",""],["GRPC_ARG_XDS_RESOURCE_DOES_NOT_EXIST_TIMEOUT_MS",""],["GRPC_ARG_XDS_ROUTING_ENABLED",""],["GRPC_COMPRESSION_CHANNEL_DEFAULT_ALGORITHM",""],["GRPC_COMPRESSION_CHANNEL_DEFAULT_LEVEL",""],["GRPC_COMPRESSION_CHANNEL_ENABLED_ALGORITHMS_BITSET",""],["GRPC_COMPRESSION_REQUEST_ALGORITHM_MD_KEY",""],["GRPC_CQ_CURRENT_VERSION",""],["GRPC_CQ_VERSION_MINIMUM_FOR_CALLBACKABLE",""],["GRPC_DEFAULT_MAX_RECV_MESSAGE_LENGTH",""],["GRPC_DEFAULT_MAX_SEND_MESSAGE_LENGTH",""],["GRPC_DEFAULT_SSL_ROOTS_FILE_PATH_ENV_VAR",""],["GRPC_GOOGLE_CREDENTIALS_ENV_VAR",""],["GRPC_IF_NAMETOINDEX",""],["GRPC_INITIAL_METADATA_CACHEABLE_REQUEST",""],["GRPC_INITIAL_METADATA_CORKED",""],["GRPC_INITIAL_METADATA_IDEMPOTENT_REQUEST",""],["GRPC_INITIAL_METADATA_USED_MASK",""],["GRPC_INITIAL_METADATA_WAIT_FOR_READY",""],["GRPC_INITIAL_METADATA_WAIT_FOR_READY_EXPLICITLY_SET",""],["GRPC_MAX_COMPLETION_QUEUE_PLUCKERS",""],["GRPC_METADATA_CREDENTIALS_PLUGIN_SYNC_MAX",""],["GRPC_SLICE_BUFFER_INLINE_ELEMENTS",""],["GRPC_SSL_SESSION_CACHE_ARG",""],["GRPC_SSL_SESSION_REUSED_PROPERTY",""],["GRPC_SSL_TARGET_NAME_OVERRIDE_ARG",""],["GRPC_SSL_TRANSPORT_SECURITY_TYPE",""],["GRPC_TCP_DEFAULT_READ_SLICE_SIZE",""],["GRPC_TRANSPORT_SECURITY_LEVEL_PROPERTY_NAME",""],["GRPC_TRANSPORT_SECURITY_TYPE_PROPERTY_NAME",""],["GRPC_USE_ABSL",""],["GRPC_WRITE_BUFFER_HINT",""],["GRPC_WRITE_NO_COMPRESS",""],["GRPC_WRITE_THROUGH",""],["GRPC_WRITE_USED_MASK",""],["GRPC_X509_CN_PROPERTY_NAME",""],["GRPC_X509_PEM_CERT_CHAIN_PROPERTY_NAME",""],["GRPC_X509_PEM_CERT_PROPERTY_NAME",""],["GRPC_X509_SAN_PROPERTY_NAME",""]],"enum":[["gpr_clock_type","The clocks we support."],["gpr_log_severity","The severity of a log message - use the #defines below when calling into gpr_log to additionally supply file and line data"],["grpc_arg_type","Type specifier for grpc_arg"],["grpc_byte_buffer_type",""],["grpc_call_error","Result of a grpc call. If the caller satisfies the prerequisites of a particular operation, the grpc_call_error returned will be GRPC_CALL_OK. Receiving any other value listed here is an indication of a bug in the caller."],["grpc_completion_type","The type of completion (for grpc_event)"],["grpc_compression_algorithm","The various compression algorithms supported by gRPC (not sorted by compression level)"],["grpc_compression_level","Compression levels allow a party with knowledge of its peer's accepted encodings to request compression in an abstract way. The level-algorithm mapping is performed internally and depends on the peer's supported compression algorithms."],["grpc_connectivity_state","Connectivity state of a channel."],["grpc_cq_completion_type","Specifies the type of APIs to use to pop events from the completion queue"],["grpc_cq_polling_type","Completion queues internally MAY maintain a set of file descriptors in a structure called 'pollset'. This enum specifies if a completion queue has an associated pollset and any restrictions on the type of file descriptors that can be present in the pollset."],["grpc_local_connect_type","Type of local connections for which local channel/server credentials will be applied. It supports UDS and local TCP connections."],["grpc_op_type",""],["grpc_security_level",""],["grpc_server_register_method_payload_handling","How to handle payloads for a registered method"],["grpc_slice_ref_whom",""],["grpc_ssl_certificate_config_reload_status","Callback results for dynamically loading a SSL certificate config."],["grpc_ssl_client_certificate_request_type",""],["grpc_ssl_roots_override_result","Results for the SSL roots override callback."],["grpc_tls_server_verification_option",""]],"fn":[["gpr_asprintf","printf to a newly-allocated string.  The set of supported formats may vary between platforms."],["gpr_atm_no_barrier_clamped_add","Adds \\a delta to \\a *value, clamping the result to the range specified by \\a min and \\a max.  Returns the new value."],["gpr_convert_clock_type","Convert a timespec from one clock to another"],["gpr_cpu_current_cpu","Return the CPU on which the current thread is executing; N.B. This should be considered advisory only - it is possible that the thread is switched to a different CPU at any time. Returns a value in range [0, gpr_cpu_num_cores() - 1]"],["gpr_cpu_num_cores","Return the number of CPU cores on the current system. Will return 0 if the information is not available."],["gpr_event_get","Return the value set by gpr_event_set(ev, ...), or NULL if no such call has completed.  If the result is non-NULL, all operations that occurred prior to the gpr_event_set(ev, ...) set will be visible after this call returns. Requires:  *ev initialized.  This operation is faster than acquiring a mutex on most platforms."],["gpr_event_init","Initialize *ev."],["gpr_event_set","Set *ev so that gpr_event_get() and gpr_event_wait() will return value. Requires:  *ev initialized; value != NULL; no prior or concurrent calls to gpr_event_set(ev, ...) since initialization."],["gpr_event_wait","Wait until *ev is set by gpr_event_set(ev, ...), or abs_deadline is exceeded, then return gpr_event_get(ev).  Requires:  *ev initialized.  Use abs_deadline==gpr_inf_future for no deadline.  When the event has been signalled before the call, this operation is faster than acquiring a mutex on most platforms."],["gpr_format_message","Returns a string allocated with gpr_malloc that contains a UTF-8 formatted error message, corresponding to the error messageid. Use in conjunction with GetLastError() et al."],["gpr_free","free"],["gpr_free_aligned","free memory allocated by gpr_malloc_aligned"],["gpr_inf_future","The zero time interval."],["gpr_inf_past","The far future"],["gpr_log","Log a message. It's advised to use GPR_xxx above to generate the context for each message"],["gpr_log_message",""],["gpr_log_severity_string","Returns a string representation of the log severity"],["gpr_log_verbosity_init",""],["gpr_malloc","malloc. If size==0, always returns NULL. Otherwise this function never returns NULL. The pointer returned is suitably aligned for any kind of variable it could contain."],["gpr_malloc_aligned","aligned malloc, never returns NULL, will align to alignment, which must be a power of 2."],["gpr_now","Return the current time measured from the given clocks epoch."],["gpr_realloc","realloc, never returns NULL"],["gpr_ref","Increment the reference count *r.  Requires *r initialized."],["gpr_ref_init","Initialize *r to value n."],["gpr_ref_is_unique","Return non-zero iff the reference count of *r is one, and thus is owned by exactly one object."],["gpr_ref_non_zero","Increment the reference count *r.  Requires *r initialized. Crashes if refcount is zero"],["gpr_refn","Increment the reference count *r by n.  Requires *r initialized, n > 0."],["gpr_set_log_function",""],["gpr_set_log_verbosity","Set global log verbosity"],["gpr_should_log",""],["gpr_sleep_until","Sleep until at least 'until' - an absolute timeout"],["gpr_stats_inc","*c += inc.  Requires: *c initialized."],["gpr_stats_init","Initialize *c to the value n."],["gpr_stats_read","Return *c.  Requires: *c initialized."],["gpr_strdup","Returns a copy of src that can be passed to gpr_free(). If allocation fails or if src is NULL, returns NULL."],["gpr_thd_currentid","Returns the identifier of the current thread."],["gpr_time_0","Time constants."],["gpr_time_add","Add and subtract times.  Calculations saturate at infinities."],["gpr_time_cmp","Return -ve, 0, or +ve according to whether a < b, a == b, or a > b respectively."],["gpr_time_from_hours",""],["gpr_time_from_micros","Return a timespec representing a given number of time units. INT64_MIN is interpreted as gpr_inf_past, and INT64_MAX as gpr_inf_future."],["gpr_time_from_millis",""],["gpr_time_from_minutes",""],["gpr_time_from_nanos",""],["gpr_time_from_seconds",""],["gpr_time_init","initialize time subsystem"],["gpr_time_max",""],["gpr_time_min",""],["gpr_time_similar","Return 1 if two times are equal or within threshold of each other, 0 otherwise"],["gpr_time_sub",""],["gpr_time_to_millis",""],["gpr_timespec_to_micros",""],["gpr_unref","Decrement the reference count *r and return non-zero iff it has reached zero. .  Requires *r initialized."],["gpr_zalloc","like malloc, but zero all bytes before returning them"],["grpc_access_token_credentials_create","Creates an Oauth2 Access Token credentials with an access token that was acquired by an out of band mechanism."],["grpc_alts_credentials_client_options_add_target_service_account","This method adds a target service account to grpc client's ALTS credentials options instance. It is used for experimental purpose for now and subject to change."],["grpc_alts_credentials_client_options_create","This method creates a grpc ALTS credentials client options instance. It is used for experimental purpose for now and subject to change."],["grpc_alts_credentials_create","This method creates an ALTS channel credential object. The security level of the resulting connection is GRPC_PRIVACY_AND_INTEGRITY. It is used for experimental purpose for now and subject to change."],["grpc_alts_credentials_options_destroy","This method destroys a grpc_alts_credentials_options instance by de-allocating all of its occupied memory. It is used for experimental purpose for now and subject to change."],["grpc_alts_credentials_server_options_create","This method creates a grpc ALTS credentials server options instance. It is used for experimental purpose for now and subject to change."],["grpc_alts_server_credentials_create","This method creates an ALTS server credential object. It is used for experimental purpose for now and subject to change."],["grpc_auth_context_add_cstring_property","Add a C string property."],["grpc_auth_context_add_property","Add a property."],["grpc_auth_context_find_properties_by_name","Finds a property in the context. May return an empty iterator (first _next will return NULL) if no property with this name was found in the context."],["grpc_auth_context_peer_identity","Gets the peer identity. Returns an empty iterator (first _next will return NULL) if the peer is not authenticated."],["grpc_auth_context_peer_identity_property_name","Gets the name of the property that indicates the peer identity. Will return NULL if the peer is not authenticated."],["grpc_auth_context_peer_is_authenticated","Returns 1 if the peer is authenticated, 0 otherwise."],["grpc_auth_context_property_iterator","Iterates over the auth context."],["grpc_auth_context_release","Releases the auth context returned from grpc_call_auth_context."],["grpc_auth_context_set_peer_identity_property_name","Sets the property name. Returns 1 if successful or 0 in case of failure (which means that no property with this name exists)."],["grpc_auth_property_iterator_next","Returns NULL when the iterator is at the end."],["grpc_byte_buffer_copy","Copies input byte buffer \\a bb."],["grpc_byte_buffer_destroy","Destroys \\a byte_buffer deallocating all its memory."],["grpc_byte_buffer_length","Returns the size of the given byte buffer, in bytes."],["grpc_byte_buffer_reader_destroy","Cleanup and destroy \\a reader"],["grpc_byte_buffer_reader_init","Initialize \\a reader to read over \\a buffer. Returns 1 upon success, 0 otherwise."],["grpc_byte_buffer_reader_next","Updates \\a slice with the next piece of data from from \\a reader and returns 1. Returns 0 at the end of the stream. Caller is responsible for calling grpc_slice_unref on the result."],["grpc_byte_buffer_reader_peek","EXPERIMENTAL API - This function may be removed and changed, in the future."],["grpc_byte_buffer_reader_readall","Merge all data from \\a reader into single slice"],["grpc_call_arena_alloc","Allocate memory in the grpc_call arena: this memory is automatically discarded at call completion"],["grpc_call_auth_context","Gets the auth context from the call. Caller needs to call grpc_auth_context_release on the returned context."],["grpc_call_cancel","Cancel an RPC. Can be called multiple times, from any thread. THREAD-SAFETY grpc_call_cancel and grpc_call_cancel_with_status are thread-safe, and can be called at any point before grpc_call_unref is called."],["grpc_call_cancel_with_status","Cancel an RPC. Can be called multiple times, from any thread. If a status has not been received for the call, set it to the status code and description passed in. Importantly, this function does not send status nor description to the remote endpoint. Note that \\a description doesn't need be a static string. It doesn't need to be alive after the call to grpc_call_cancel_with_status completes."],["grpc_call_credentials_release","Releases a call credentials object. The creator of the credentials object is responsible for its release."],["grpc_call_details_destroy",""],["grpc_call_details_init",""],["grpc_call_error_to_string","Convert grpc_call_error values to a string"],["grpc_call_get_peer","Returns a newly allocated string representing the endpoint to which this call is communicating with. The string is in the uri format accepted by grpc_channel_create. The returned string should be disposed of with gpr_free()."],["grpc_call_ref","Ref a call. THREAD SAFETY: grpc_call_ref is thread-compatible"],["grpc_call_set_credentials","Sets a credentials to a call. Can only be called on the client side before grpc_call_start_batch."],["grpc_call_start_batch","Start a batch of operations defined in the array ops; when complete, post a completion of type 'tag' to the completion queue bound to the call. The order of ops specified in the batch has no significance. Only one operation of each type can be active at once in any given batch. If a call to grpc_call_start_batch returns GRPC_CALL_OK you must call grpc_completion_queue_next or grpc_completion_queue_pluck on the completion queue associated with 'call' for work to be performed. If a call to grpc_call_start_batch returns any value other than GRPC_CALL_OK it is guaranteed that no state associated with 'call' is changed and it is not appropriate to call grpc_completion_queue_next or grpc_completion_queue_pluck consequent to the failed grpc_call_start_batch call. If a call to grpc_call_start_batch with an empty batch returns GRPC_CALL_OK, the tag is put in the completion queue immediately. THREAD SAFETY: access to grpc_call_start_batch in multi-threaded environment needs to be synchronized. As an optimization, you may synchronize batches containing just send operations independently from batches containing just receive operations. Access to grpc_call_start_batch with an empty batch is thread-compatible."],["grpc_call_unref","Unref a call. THREAD SAFETY: grpc_call_unref is thread-compatible"],["grpc_census_call_get_context","Retrieve the calls current census context."],["grpc_census_call_set_context","Set census context for a call; Must be called before first call to grpc_call_start_batch()."],["grpc_channel_check_connectivity_state","Check the connectivity state of a channel."],["grpc_channel_create_call","Create a call given a grpc_channel, in order to call 'method'. All completions are sent to 'completion_queue'. 'method' and 'host' need only live through the invocation of this function. If parent_call is non-NULL, it must be a server-side call. It will be used to propagate properties from the server call to this new client call, depending on the value of \\a propagation_mask (see propagation_bits.h for possible values)."],["grpc_channel_create_registered_call","Create a call given a handle returned from grpc_channel_register_call. \\sa grpc_channel_create_call."],["grpc_channel_credentials_release","Releases a channel credentials object. The creator of the credentials object is responsible for its release."],["grpc_channel_destroy","Close and destroy a grpc channel"],["grpc_channel_get_info","Request info about the channel. \\a channel_info indicates what information is being requested and how that information will be returned. \\a channel_info is owned by the caller."],["grpc_channel_get_target","Return a newly allocated string representing the target a channel was created for."],["grpc_channel_num_external_connectivity_watchers","Number of active \"external connectivity state watchers\" attached to a channel. Useful for testing."],["grpc_channel_ping","Ping the channels peer (load balanced channels will select one sub-channel to ping); if the channel is not connected, posts a failed."],["grpc_channel_register_call","Pre-register a method/host pair on a channel. method and host are not owned and must remain alive while the channel is alive."],["grpc_channel_reset_connect_backoff","EXPERIMENTAL.  Resets the channel's connect backoff. TODO(roth): When we see whether this proves useful, either promote to non-experimental or remove it."],["grpc_channel_support_connectivity_watcher","Check whether a grpc channel supports connectivity watcher"],["grpc_channel_watch_connectivity_state","Watch for a change in connectivity state. Once the channel connectivity state is different from last_observed_state, tag will be enqueued on cq with success=1. If deadline expires BEFORE the state is changed, tag will be enqueued on cq with success=0."],["grpc_channelz_get_channel",""],["grpc_channelz_get_server",""],["grpc_channelz_get_server_sockets",""],["grpc_channelz_get_servers",""],["grpc_channelz_get_socket",""],["grpc_channelz_get_subchannel",""],["grpc_channelz_get_top_channels","CHANNELZ API *************/ churn as the feature is implemented. This comment will be removed once channelz is officially supported, and these APIs become stable. For now you may track the progress by following this github issue: https://github.com/grpc/grpc/issues/15340"],["grpc_completion_queue_create","Create a completion queue"],["grpc_completion_queue_create_for_callback","Helper function to create a completion queue with grpc_cq_completion_type of GRPC_CQ_CALLBACK and grpc_cq_polling_type of GRPC_CQ_DEFAULT_POLLING. This function is experimental."],["grpc_completion_queue_create_for_next","Helper function to create a completion queue with grpc_cq_completion_type of GRPC_CQ_NEXT and grpc_cq_polling_type of GRPC_CQ_DEFAULT_POLLING"],["grpc_completion_queue_create_for_pluck","Helper function to create a completion queue with grpc_cq_completion_type of GRPC_CQ_PLUCK and grpc_cq_polling_type of GRPC_CQ_DEFAULT_POLLING"],["grpc_completion_queue_destroy","Destroy a completion queue. The caller must ensure that the queue is drained and no threads are executing grpc_completion_queue_next"],["grpc_completion_queue_factory_lookup","Returns the completion queue factory based on the attributes. MAY return a NULL if no factory can be found"],["grpc_completion_queue_next","Blocks until an event is available, the completion queue is being shut down, or deadline is reached."],["grpc_completion_queue_pluck","Blocks until an event with tag 'tag' is available, the completion queue is being shutdown or deadline is reached."],["grpc_completion_queue_shutdown","Begin destruction of a completion queue. Once all possible events are drained then grpc_completion_queue_next will start to produce GRPC_QUEUE_SHUTDOWN events only. At that point it's safe to call grpc_completion_queue_destroy."],["grpc_completion_queue_thread_local_cache_flush","EXPERIMENTAL API ************/ Returns 1 if there was contents in the cache.  If there was an event in \\a cq tls cache, its tag is placed in tag, and ok is set to the event success."],["grpc_completion_queue_thread_local_cache_init","EXPERIMENTAL API ************/ grpc_flush_cq_tls_cache() MUST be called on the same thread, with the same cq."],["grpc_composite_call_credentials_create","Creates a composite call credentials object."],["grpc_composite_channel_credentials_create","Creates a composite channel credentials object. The security level of resulting connection is determined by channel_creds."],["grpc_compression_algorithm_for_level","Returns the compression algorithm corresponding to \\a level for the compression algorithms encoded in the \\a accepted_encodings bitset."],["grpc_compression_algorithm_is_message","Return if an algorithm is message compression algorithm."],["grpc_compression_algorithm_is_stream","Return if an algorithm is stream compression algorithm."],["grpc_compression_algorithm_name","Updates \\a name with the encoding name corresponding to a valid \\a algorithm. Note that \\a name is statically allocated and must not be freed. Returns 1 upon success, 0 otherwise."],["grpc_compression_algorithm_parse","Parses the \\a slice as a grpc_compression_algorithm instance and updating \\a algorithm. Returns 1 upon success, 0 otherwise."],["grpc_compression_options_disable_algorithm","Mark \\a algorithm as disabled in \\a opts."],["grpc_compression_options_enable_algorithm","Mark \\a algorithm as enabled in \\a opts."],["grpc_compression_options_init",""],["grpc_compression_options_is_algorithm_enabled","Returns true if \\a algorithm is marked as enabled in \\a opts."],["grpc_cronet_secure_channel_create",""],["grpc_empty_slice",""],["grpc_g_stands_for","Return a string specifying what the 'g' in gRPC stands for"],["grpc_google_compute_engine_credentials_create","Creates a compute engine credentials object for connecting to Google. WARNING: Do NOT use this credentials to connect to a non-google service as this could result in an oauth2 token leak."],["grpc_google_default_credentials_create","Creates default credentials to connect to a google gRPC service. WARNING: Do NOT use this credentials to connect to a non-google service as this could result in an oauth2 token leak. The security level of the resulting connection is GRPC_PRIVACY_AND_INTEGRITY."],["grpc_google_iam_credentials_create","Creates an IAM credentials object for connecting to Google."],["grpc_google_refresh_token_credentials_create","Creates an Oauth2 Refresh Token credentials object for connecting to Google. May return NULL if the input is invalid. WARNING: Do NOT use this credentials to connect to a non-google service as this could result in an oauth2 token leak. - json_refresh_token is the JSON string containing the refresh token itself along with a client_id and client_secret."],["grpc_header_key_is_legal","Check whether a metadata key is legal (will be accepted by core)"],["grpc_header_nonbin_value_is_legal","Check whether a non-binary metadata value is legal (will be accepted by core)"],["grpc_init","Initialize the grpc library."],["grpc_insecure_channel_create","Create a client channel to 'target'. Additional channel level configuration MAY be provided by grpc_channel_args, though the expectation is that most clients will want to simply pass NULL. The user data in 'args' need only live through the invocation of this function. However, if any args of the 'pointer' type are passed, then the referenced vtable must be maintained by the caller until grpc_channel_destroy terminates. See grpc_channel_args definition for more on this."],["grpc_insecure_channel_create_from_fd","Create a client channel to 'target' using file descriptor 'fd'. The 'target' argument will be used to indicate the name for this channel. See the comment for grpc_insecure_channel_create for description of 'args' argument."],["grpc_is_binary_header","Check whether a metadata key corresponds to a binary value"],["grpc_is_initialized","EXPERIMENTAL. Returns 1 if the grpc library has been initialized. TODO(ericgribkoff) Decide if this should be promoted to non-experimental as part of stabilizing the fork support API, as tracked in https://github.com/grpc/grpc/issues/15334"],["grpc_lame_client_channel_create","Create a lame client: this client fails every operation attempted on it."],["grpc_local_credentials_create","This method creates a local channel credential object. The security level of the resulting connection is GRPC_PRIVACY_AND_INTEGRITY for UDS and GRPC_SECURITY_NONE for LOCAL_TCP. It is used for experimental purpose for now and subject to change."],["grpc_local_server_credentials_create","This method creates a local server credential object. It is used for experimental purpose for now and subject to change."],["grpc_max_auth_token_lifetime",""],["grpc_metadata_array_destroy",""],["grpc_metadata_array_init","\\mainpage GRPC Core"],["grpc_metadata_credentials_create_from_plugin","Creates a credentials object from a plugin with a specified minimum security level."],["grpc_raw_byte_buffer_create","Returns a RAW byte buffer instance over the given slices (up to \\a nslices)."],["grpc_raw_byte_buffer_from_reader","Returns a RAW byte buffer instance from the output of \\a reader."],["grpc_raw_compressed_byte_buffer_create","Returns a compressed RAW byte buffer instance over the given slices (up to \\a nslices). The \\a compression argument defines the compression algorithm used to generate the data in \\a slices."],["grpc_register_plugin","Registers a plugin to be initialized and destroyed with the library."],["grpc_resource_quota_arg_vtable","Fetch a vtable for a grpc_channel_arg that points to a grpc_resource_quota"],["grpc_resource_quota_create","Create a buffer pool"],["grpc_resource_quota_ref","Add a reference to a buffer pool"],["grpc_resource_quota_resize","Update the size of a buffer pool"],["grpc_resource_quota_set_max_threads","Update the size of the maximum number of threads allowed"],["grpc_resource_quota_unref","Drop a reference to a buffer pool"],["grpc_secure_channel_create","Creates a secure channel using the passed-in credentials. Additional channel level configuration MAY be provided by grpc_channel_args, though the expectation is that most clients will want to simply pass NULL. The user data in 'args' need only live through the invocation of this function. However, if any args of the 'pointer' type are passed, then the referenced vtable must be maintained by the caller until grpc_channel_destroy terminates. See grpc_channel_args definition for more on this."],["grpc_server_add_insecure_channel_from_fd","Add the connected communication channel based on file descriptor 'fd' to the 'server'. The 'fd' must be an open file descriptor corresponding to a connected socket. Events from the file descriptor may come on any of the server completion queues (i.e completion queues registered via the grpc_server_register_completion_queue API)."],["grpc_server_add_insecure_http2_port","Add a HTTP2 over plaintext over tcp listener. Returns bound port number on success, 0 on failure. REQUIRES: server not started"],["grpc_server_add_secure_http2_port","Add a HTTP2 over an encrypted link over tcp listener. Returns bound port number on success, 0 on failure. REQUIRES: server not started"],["grpc_server_cancel_all_calls","Cancel all in-progress calls. Only usable after shutdown."],["grpc_server_create","Create a server. Additional configuration for each incoming channel can be specified with args. If no additional configuration is needed, args can be NULL. The user data in 'args' need only live through the invocation of this function. However, if any args of the 'pointer' type are passed, then the referenced vtable must be maintained by the caller until grpc_server_destroy terminates. See grpc_channel_args definition for more on this."],["grpc_server_credentials_release","Releases a server_credentials object. The creator of the server_credentials object is responsible for its release."],["grpc_server_credentials_set_auth_metadata_processor",""],["grpc_server_destroy","Destroy a server. Shutdown must have completed beforehand (i.e. all tags generated by grpc_server_shutdown_and_notify must have been received, and at least one call to grpc_server_shutdown_and_notify must have been made)."],["grpc_server_register_completion_queue","Register a completion queue with the server. Must be done for any notification completion queue that is passed to grpc_server_request_*_call and to grpc_server_shutdown_and_notify. Must be performed prior to grpc_server_start."],["grpc_server_register_method","Registers a method in the server. Methods to this (host, method) pair will not be reported by grpc_server_request_call, but instead be reported by grpc_server_request_registered_call when passed the appropriate registered_method (as returned by this function). Must be called before grpc_server_start. Returns NULL on failure."],["grpc_server_request_call","Request notification of a new call. Once a call is received, a notification tagged with \\a tag_new is added to \\a cq_for_notification. \\a call, \\a details and \\a request_metadata are updated with the appropriate call information. \\a cq_bound_to_call is bound to \\a call, and batch operation notifications for that call will be posted to \\a cq_bound_to_call. Note that \\a cq_for_notification must have been registered to the server via \\a grpc_server_register_completion_queue."],["grpc_server_request_registered_call","Request notification of a new pre-registered call. 'cq_for_notification' must have been registered to the server via grpc_server_register_completion_queue."],["grpc_server_shutdown_and_notify","Begin shutting down a server. After completion, no new calls or connections will be admitted. Existing calls will be allowed to complete. Send a GRPC_OP_COMPLETE event when there are no more calls being serviced. Shutdown is idempotent, and all tags will be notified at once if multiple grpc_server_shutdown_and_notify calls are made. 'cq' must have been registered to this server via grpc_server_register_completion_queue."],["grpc_server_start","Start a server - tells all listeners to start listening"],["grpc_service_account_jwt_access_credentials_create","Creates a JWT credentials object. May return NULL if the input is invalid. - json_key is the JSON key string containing the client's private key. - token_lifetime is the lifetime of each Json Web Token (JWT) created with this credentials.  It should not exceed grpc_max_auth_token_lifetime or will be cropped to this value."],["grpc_set_ssl_roots_override_callback","Setup a callback to override the default TLS/SSL roots. This function is not thread-safe and must be called at initialization time before any ssl credentials are created to have the desired side effect. If GRPC_DEFAULT_SSL_ROOTS_FILE_PATH environment is set to a valid path, the callback will not be called."],["grpc_shutdown","Shut down the grpc library."],["grpc_shutdown_blocking","EXPERIMENTAL. Blocking shut down grpc library. This is only for wrapped language to use now."],["grpc_slice_buf_start_eq","return non-zero if the first blen bytes of a are equal to b"],["grpc_slice_buffer_add","Add an element to a slice buffer - takes ownership of the slice. This function is allowed to concatenate the passed in slice to the end of some other slice if desired by the slice buffer."],["grpc_slice_buffer_add_indexed","add an element to a slice buffer - takes ownership of the slice and returns the index of the slice. Guarantees that the slice will not be concatenated at the end of another slice (i.e. the data for this slice will begin at the first byte of the slice at the returned index in sb->slices) The implementation MAY decide to concatenate data at the end of a small slice added in this fashion."],["grpc_slice_buffer_addn",""],["grpc_slice_buffer_destroy","destroy a slice buffer - unrefs any held elements"],["grpc_slice_buffer_init","initialize a slice buffer"],["grpc_slice_buffer_move_first","move the first n bytes of src into dst"],["grpc_slice_buffer_move_first_into_buffer","move the first n bytes of src into dst (copying them)"],["grpc_slice_buffer_move_first_no_ref","move the first n bytes of src into dst without adding references"],["grpc_slice_buffer_move_into","move all of the elements of src into dst"],["grpc_slice_buffer_pop","pop the last buffer, but don't unref it"],["grpc_slice_buffer_reset_and_unref","clear a slice buffer, unref all elements"],["grpc_slice_buffer_swap","swap the contents of two slice buffers"],["grpc_slice_buffer_take_first","take the first slice in the slice buffer"],["grpc_slice_buffer_tiny_add","add a very small (less than 8 bytes) amount of data to the end of a slice buffer: returns a pointer into which to add the data"],["grpc_slice_buffer_trim_end","remove n bytes from the end of a slice buffer"],["grpc_slice_buffer_undo_take_first","undo the above with (a possibly different) \\a slice"],["grpc_slice_chr",""],["grpc_slice_cmp","Returns <0 if a < b, ==0 if a == b, >0 if a > b The order is arbitrary, and is not guaranteed to be stable across different versions of the API."],["grpc_slice_copy","Copy slice - create a new slice that contains the same data as s"],["grpc_slice_default_eq_impl",""],["grpc_slice_default_hash_impl",""],["grpc_slice_dup","Return a slice pointing to newly allocated memory that has the same contents as \\a s"],["grpc_slice_eq",""],["grpc_slice_from_copied_buffer","Create a slice by copying a buffer. Equivalent to: grpc_slice slice = grpc_slice_malloc(len); memcpy(slice->data, source, len);"],["grpc_slice_from_copied_string","Create a slice by copying a string. Does not preserve null terminators. Equivalent to: size_t len = strlen(source); grpc_slice slice = grpc_slice_malloc(len); memcpy(slice->data, source, len);"],["grpc_slice_from_static_buffer","Create a slice pointing to constant memory"],["grpc_slice_from_static_string","Create a slice pointing to constant memory"],["grpc_slice_hash",""],["grpc_slice_intern","Intern a slice:"],["grpc_slice_is_equivalent","Do two slices point at the same memory, with the same length If a or b is inlined, actually compares data"],["grpc_slice_malloc","Equivalent to grpc_slice_new(malloc(len), len, free), but saves one malloc() call. Aborts if malloc() fails."],["grpc_slice_malloc_large",""],["grpc_slice_new","Create a slice pointing at some data. Calls malloc to allocate a refcount for the object, and arranges that destroy will be called with the pointer passed in at destruction."],["grpc_slice_new_with_len","Equivalent to grpc_slice_new, but with a two argument destroy function that also takes the slice length."],["grpc_slice_new_with_user_data","Equivalent to grpc_slice_new, but with a separate pointer that is passed to the destroy function.  This function can be useful when the data is part of a larger structure that must be destroyed when the data is no longer needed."],["grpc_slice_rchr","return the index of the last instance of \\a c in \\a s, or -1 if not found"],["grpc_slice_ref","Increment the refcount of s. Requires slice is initialized. Returns s."],["grpc_slice_slice","return the index of the first occurrence of \\a needle in \\a haystack, or -1 if it's not found"],["grpc_slice_split_head","Splits s into two: modifies s to be s[split:s.length], and returns a new slice, sharing a refcount with s, that contains s[0:split]. Requires s initialized, split <= s.length"],["grpc_slice_split_tail","Splits s into two: modifies s to be s[0:split], and returns a new slice, sharing a refcount with s, that contains s[split:s.length]. Requires s initialized, split <= s.length"],["grpc_slice_split_tail_maybe_ref","The same as grpc_slice_split_tail, but with an option to skip altering refcounts (grpc_slice_split_tail_maybe_ref(..., true) is equivalent to grpc_slice_split_tail(...))"],["grpc_slice_str_cmp",""],["grpc_slice_sub","Return a result slice derived from s, which shares a ref count with \\a s, where result.data==s.data+begin, and result.length==end-begin. The ref count of \\a s is increased by one. Do not assign result back to \\a s. Requires s initialized, begin <= end, begin <= s.length, and end <= source->length."],["grpc_slice_sub_no_ref","The same as grpc_slice_sub, but without altering the ref count"],["grpc_slice_to_c_string","Return a copy of slice as a C string. Offers no protection against embedded NULL's. Returned string must be freed with gpr_free."],["grpc_slice_unref","Decrement the ref count of s.  If the ref count of s reaches zero, all slices sharing the ref count are destroyed, and considered no longer initialized.  If s is ultimately derived from a call to grpc_slice_new(start, len, dest) where dest!=NULL , then (*dest)(start) is called, else if s is ultimately derived from a call to grpc_slice_new_with_len(start, len, dest) where dest!=NULL , then (*dest)(start, len).  Requires s initialized."],["grpc_ssl_credentials_create","Deprecated in favor of grpc_ssl_server_credentials_create_ex. It will be removed after all of its call sites are migrated to grpc_ssl_server_credentials_create_ex. Creates an SSL credentials object. The security level of the resulting connection is GRPC_PRIVACY_AND_INTEGRITY. - pem_root_certs is the NULL-terminated string containing the PEM encoding of the server root certificates. If this parameter is NULL, the implementation will first try to dereference the file pointed by the GRPC_DEFAULT_SSL_ROOTS_FILE_PATH environment variable, and if that fails, try to get the roots set by grpc_override_ssl_default_roots. Eventually, if all these fail, it will try to get the roots from a well-known place on disk (in the grpc install directory)."],["grpc_ssl_credentials_create_ex",""],["grpc_ssl_server_certificate_config_create","Creates a grpc_ssl_server_certificate_config object. - pem_roots_cert is the NULL-terminated string containing the PEM encoding of the client root certificates. This parameter may be NULL if the server does not want the client to be authenticated with SSL. - pem_key_cert_pairs is an array private key / certificate chains of the server. This parameter cannot be NULL. - num_key_cert_pairs indicates the number of items in the private_key_files and cert_chain_files parameters. It must be at least 1. - It is the caller's responsibility to free this object via grpc_ssl_server_certificate_config_destroy()."],["grpc_ssl_server_certificate_config_destroy","Destroys a grpc_ssl_server_certificate_config object."],["grpc_ssl_server_credentials_create","Deprecated in favor of grpc_ssl_server_credentials_create_ex. Creates an SSL server_credentials object. - pem_roots_cert is the NULL-terminated string containing the PEM encoding of the client root certificates. This parameter may be NULL if the server does not want the client to be authenticated with SSL. - pem_key_cert_pairs is an array private key / certificate chains of the server. This parameter cannot be NULL. - num_key_cert_pairs indicates the number of items in the private_key_files and cert_chain_files parameters. It should be at least 1. - force_client_auth, if set to non-zero will force the client to authenticate with an SSL cert. Note that this option is ignored if pem_root_certs is NULL."],["grpc_ssl_server_credentials_create_ex","Deprecated in favor of grpc_ssl_server_credentials_create_with_options. Same as grpc_ssl_server_credentials_create method except uses grpc_ssl_client_certificate_request_type enum to support more ways to authenticate client certificates."],["grpc_ssl_server_credentials_create_options_using_config","Creates an options object using a certificate config. Use this method when the certificates and keys of the SSL server will not change during the server's lifetime. - Takes ownership of the certificate_config parameter."],["grpc_ssl_server_credentials_create_options_using_config_fetcher","Creates an options object using a certificate config fetcher. Use this method to reload the certificates and keys of the SSL server without interrupting the operation of the server. Initial certificate config will be fetched during server initialization. - user_data parameter, if not NULL, contains opaque data which will be passed to the fetcher (see definition of grpc_ssl_server_certificate_config_callback)."],["grpc_ssl_server_credentials_create_with_options","Creates an SSL server_credentials object using the provided options struct. - Takes ownership of the options parameter."],["grpc_ssl_server_credentials_options_destroy","Destroys a grpc_ssl_server_credentials_options object."],["grpc_ssl_session_cache_create_channel_arg","Create a channel arg with the given cache object."],["grpc_ssl_session_cache_create_lru","Create LRU cache for client-side SSL sessions with the given capacity. If capacity is < 1, a default capacity is used instead."],["grpc_ssl_session_cache_destroy","Destroy SSL session cache."],["grpc_sts_credentials_create","Creates an STS credentials following the STS Token Exchanged specifed in the IETF draft https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16. This API is used for experimental purposes for now and may change in the future."],["grpc_tls_credential_reload_config_create","Create a grpc_tls_credential_reload_config instance. - config_user_data is config-specific, read-only user data that works for all channels created with a credential using the config. - schedule is a pointer to an application-provided callback used to invoke credential reload API. The implementation of this method has to be non-blocking, but can be performed synchronously or asynchronously. 1) If processing occurs synchronously, it populates arg->key_materials_config, arg->status, and arg->error_details and returns zero. 2) If processing occurs asynchronously, it returns a non-zero value. The application then invokes arg->cb when processing is completed. Note that arg->cb cannot be invoked before schedule API returns. - cancel is a pointer to an application-provided callback used to cancel a credential reload request scheduled via an asynchronous schedule API. arg is used to pinpoint an exact reloading request to be cancelled. The operation may not have any effect if the request has already been processed. - destruct is a pointer to an application-provided callback used to clean up any data associated with the config. It is used for experimental purpose for now and subject to change."],["grpc_tls_credentials_create","This method creates a TLS channel credential object. It takes ownership of the options parameter. The security level of the resulting connection is GRPC_PRIVACY_AND_INTEGRITY."],["grpc_tls_credentials_options_create","Create an empty TLS credentials options. It is used for experimental purpose for now and subject to change."],["grpc_tls_credentials_options_set_cert_request_type","Set grpc_ssl_client_certificate_request_type field in credentials options with the provided type. options should not be NULL. It returns 1 on success and 0 on failure. It is used for experimental purpose for now and subject to change."],["grpc_tls_credentials_options_set_credential_reload_config","Set grpc_tls_credential_reload_config field in credentials options with the provided config struct whose ownership is transferred. Both parameters should not be NULL. It returns 1 on success and 0 on failure. It is used for experimental purpose for now and subject to change."],["grpc_tls_credentials_options_set_key_materials_config","Set grpc_tls_key_materials_config field in credentials options with the provided config struct whose ownership is transferred. Both parameters should not be NULL. It returns 1 on success and 0 on failure. It is used for experimental purpose for now and subject to change."],["grpc_tls_credentials_options_set_server_authorization_check_config","Set grpc_tls_server_authorization_check_config field in credentials options with the provided config struct whose ownership is transferred. Both parameters should not be NULL. It returns 1 on success and 0 on failure. It is used for experimental purpose for now and subject to change."],["grpc_tls_credentials_options_set_server_verification_option","Set grpc_tls_server_verification_option field in credentials options with the provided server_verification_option. options should not be NULL. This should be called only on the client side. If grpc_tls_server_verification_option is not GRPC_TLS_SERVER_VERIFICATION, use of a customer server authorization check (grpc_tls_server_authorization_check_config) will be mandatory. It returns 1 on success and 0 on failure. It is used for experimental purpose for now and subject to change."],["grpc_tls_key_materials_config_create","Create an empty grpc_tls_key_materials_config instance. It is used for experimental purpose for now and subject to change."],["grpc_tls_key_materials_config_get_version","Get the version number of a grpc_tls_key_materials_config instance. It returns the version number on success and -1 on failure. It is used for experimental purpose for now and subject to change."],["grpc_tls_key_materials_config_set_key_materials","Set grpc_tls_key_materials_config instance with provided a TLS certificate. It's valid for the caller to provide nullptr pem_root_certs, in which case the gRPC-provided root cert will be used. pem_key_cert_pairs should not be NULL. The ownerships of |pem_root_certs| and |pem_key_cert_pairs| remain with the caller. It returns 1 on success and 0 on failure. It is used for experimental purpose for now and subject to change."],["grpc_tls_key_materials_config_set_version","Set grpc_tls_key_materials_config instance with a provided version number, which is used to keep track of the version of key materials. It returns 1 on success and 0 on failure. It is used for experimental purpose for now and subject to change."],["grpc_tls_server_authorization_check_config_create","Create a grpc_tls_server_authorization_check_config instance. - config_user_data is config-specific, read-only user data that works for all channels created with a credential using the config. - schedule is a pointer to an application-provided callback used to invoke server authorization check API. The implementation of this method has to be non-blocking, but can be performed synchronously or asynchronously. 1)If processing occurs synchronously, it populates arg->result, arg->status, and arg->error_details and returns zero. 2) If processing occurs asynchronously, it returns a non-zero value. The application then invokes arg->cb when processing is completed. Note that arg->cb cannot be invoked before schedule API returns. - cancel is a pointer to an application-provided callback used to cancel a server authorization check request scheduled via an asynchronous schedule API. arg is used to pinpoint an exact check request to be cancelled. The operation may not have any effect if the request has already been processed. - destruct is a pointer to an application-provided callback used to clean up any data associated with the config. It is used for experimental purpose for now and subject to change."],["grpc_tls_server_credentials_create","This method creates a TLS server credential object. It takes ownership of the options parameter."],["grpc_tracer_set_enabled","Enable or disable a tracer."],["grpc_version_string","Return a string representing the current version of grpc"],["grpcwrap_batch_context_create",""],["grpcwrap_batch_context_destroy",""],["grpcwrap_batch_context_recv_close_on_server_cancelled",""],["grpcwrap_batch_context_recv_initial_metadata",""],["grpcwrap_batch_context_recv_status_on_client_details",""],["grpcwrap_batch_context_recv_status_on_client_status",""],["grpcwrap_batch_context_recv_status_on_client_trailing_metadata",""],["grpcwrap_batch_context_take_recv_message",""],["grpcwrap_call_kick_completion_queue","Kick call's completion queue, it should be called after there is an event ready to poll. THREAD SAFETY: grpcwrap_call_kick_completion_queue is thread-safe because it does not change the call's state."],["grpcwrap_call_recv_initial_metadata",""],["grpcwrap_call_recv_message",""],["grpcwrap_call_send_close_from_client",""],["grpcwrap_call_send_initial_metadata",""],["grpcwrap_call_send_message",""],["grpcwrap_call_send_status_from_server",""],["grpcwrap_call_start_client_streaming",""],["grpcwrap_call_start_duplex_streaming",""],["grpcwrap_call_start_server_streaming",""],["grpcwrap_call_start_serverside",""],["grpcwrap_call_start_unary",""],["grpcwrap_channel_args_create",""],["grpcwrap_channel_args_destroy",""],["grpcwrap_channel_args_set_integer",""],["grpcwrap_channel_args_set_pointer_vtable",""],["grpcwrap_channel_args_set_string",""],["grpcwrap_channel_create_call",""],["grpcwrap_metadata_array_add",""],["grpcwrap_metadata_array_cleanup",""],["grpcwrap_metadata_array_destroy_full",""],["grpcwrap_metadata_array_destroy_metadata_including_entries",""],["grpcwrap_metadata_array_destroy_metadata_only",""],["grpcwrap_metadata_array_get_key",""],["grpcwrap_metadata_array_get_value",""],["grpcwrap_metadata_array_init",""],["grpcwrap_metadata_array_move",""],["grpcwrap_metadata_array_shrink_to_fit",""],["grpcwrap_request_call_context_create",""],["grpcwrap_request_call_context_deadline",""],["grpcwrap_request_call_context_destroy",""],["grpcwrap_request_call_context_get_call",""],["grpcwrap_request_call_context_host",""],["grpcwrap_request_call_context_metadata_array",""],["grpcwrap_request_call_context_method",""],["grpcwrap_request_call_context_ref_call",""],["grpcwrap_server_request_call",""],["grpcwrap_slice_copy",""],["grpcwrap_slice_length",""],["grpcwrap_slice_raw_offset",""],["grpcwrap_slice_ref",""],["grpcwrap_slice_unref",""]],"mod":[["grpc_status_code",""]],"struct":[["census_context",""],["gpr_event",""],["gpr_log_func_args","Log overrides: applications can use this API to intercept logging calls and use their own implementations"],["gpr_refcount",""],["gpr_stats_counter",""],["gpr_timespec","Analogous to struct timespec. On some machines, absolute times may be in local time."],["grpc_alarm",""],["grpc_alts_credentials_options",""],["grpc_arg","A single argument... each argument has a key and a value"],["grpc_arg_grpc_arg_value_grpc_arg_pointer",""],["grpc_arg_pointer_vtable",""],["grpc_auth_context",""],["grpc_auth_metadata_context","Context that can be used by metadata credentials plugin in order to create auth related metadata."],["grpc_auth_metadata_processor","Pluggable server-side metadata processor object."],["grpc_auth_property","value, if not NULL, is guaranteed to be NULL terminated."],["grpc_auth_property_iterator",""],["grpc_byte_buffer",""],["grpc_byte_buffer_grpc_byte_buffer_data__bindgen_ty_1",""],["grpc_byte_buffer_grpc_byte_buffer_data_grpc_compressed_buffer",""],["grpc_byte_buffer_reader","Reader for byte buffers. Iterates over slices in the byte buffer"],["grpc_call",""],["grpc_call_credentials",""],["grpc_call_details",""],["grpc_channel",""],["grpc_channel_args","An array of arguments that can be passed around."],["grpc_channel_credentials",""],["grpc_channel_info","Information requested from the channel."],["grpc_completion_queue",""],["grpc_completion_queue_attributes",""],["grpc_completion_queue_factory",""],["grpc_compression_options",""],["grpc_compression_options_grpc_compression_options_default_algorithm","The default message compression algorithm. It'll be used in the absence of call specific settings. This option corresponds to the channel argument key behind \\a GRPC_COMPRESSION_CHANNEL_DEFAULT_ALGORITHM."],["grpc_compression_options_grpc_compression_options_default_level","The default compression level. It'll be used in the absence of call specific settings. This option corresponds to the channel argument key behind \\a GRPC_COMPRESSION_CHANNEL_DEFAULT_LEVEL. If present, takes precedence over \\a default_algorithm. TODO(dgq): currently only available for server channels."],["grpc_event","The result of an operation."],["grpc_experimental_completion_queue_functor","EXPERIMENTAL: Specifies an interface class to be used as a tag for callback-based completion queues. This can be used directly, as the first element of a struct in C, or as a base class in C++. Its \"run\" value should be assigned to some non-member function, such as a static method."],["grpc_metadata","A single metadata element"],["grpc_metadata__bindgen_ty_1","The following fields are reserved for grpc internal use. There is no need to initialize them, and they will be set to garbage during calls to grpc."],["grpc_metadata_array",""],["grpc_metadata_credentials_plugin","grpc_metadata_credentials plugin is an API user provided structure used to create grpc_credentials objects that can be set on a channel (composed) or a call. See grpc_credentials_metadata_create_from_plugin below. The grpc client stack will call the get_metadata method of the plugin for every call in scope for the credentials created from it."],["grpc_op","Operation data: one field for each op type (except SEND_CLOSE_FROM_CLIENT which has no arguments)"],["grpc_op_grpc_op_data__bindgen_ty_1","Reserved for future usage"],["grpc_op_grpc_op_data_grpc_op_recv_close_on_server",""],["grpc_op_grpc_op_data_grpc_op_recv_initial_metadata","ownership of the array is with the caller, but ownership of the elements stays with the call object (ie key, value members are owned by the call object, recv_initial_metadata->array is owned by the caller). After the operation completes, call grpc_metadata_array_destroy on this value, or reuse it in a future op."],["grpc_op_grpc_op_data_grpc_op_recv_message","ownership of the byte buffer is moved to the caller; the caller must call grpc_byte_buffer_destroy on this value, or reuse it in a future op. The returned byte buffer will be NULL if trailing metadata was received instead of a message."],["grpc_op_grpc_op_data_grpc_op_recv_status_on_client",""],["grpc_op_grpc_op_data_grpc_op_send_initial_metadata",""],["grpc_op_grpc_op_data_grpc_op_send_initial_metadata_grpc_op_send_initial_metadata_maybe_compression_level","If \\a is_set, \\a compression_level will be used for the call. Otherwise, \\a compression_level won't be considered"],["grpc_op_grpc_op_data_grpc_op_send_message",""],["grpc_op_grpc_op_data_grpc_op_send_status_from_server",""],["grpc_resource_quota",""],["grpc_server",""],["grpc_server_credentials",""],["grpc_slice","A grpc_slice s, if initialized, represents the byte range s.bytes[0..s.length-1]."],["grpc_slice_buffer","Represents an expandable array of slices, to be interpreted as a single item."],["grpc_slice_grpc_slice_data_grpc_slice_inlined",""],["grpc_slice_grpc_slice_data_grpc_slice_refcounted",""],["grpc_slice_refcount",""],["grpc_socket_factory",""],["grpc_socket_mutator",""],["grpc_ssl_pem_key_cert_pair","Object that holds a private key / certificate chain pair in PEM format."],["grpc_ssl_server_certificate_config",""],["grpc_ssl_server_credentials_options",""],["grpc_ssl_session_cache",""],["grpc_ssl_verify_peer_options","Object that holds additional peer-verification options on a secure channel."],["grpc_sts_credentials_options","Options for creating STS Oauth Token Exchange credentials following the IETF draft https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16. Optional fields may be set to NULL or empty string. It is the responsibility of the caller to ensure that the subject and actor tokens are refreshed on disk at the specified paths. This API is used for experimental purposes for now and may change in the future."],["grpc_tls_credential_reload_arg","A struct containing all information necessary to schedule/cancel a credential reload request. - cb and cb_user_data represent a gRPC-provided callback and an argument passed to it. - key_materials_config is an in/output parameter containing currently used/newly reloaded credentials. If credential reload does not result in a new credential, key_materials_config should not be modified. The same key_materials_config object can be updated if new key materials is available. - status and error_details are used to hold information about errors occurred when a credential reload request is scheduled/cancelled. - config is a pointer to the unique grpc_tls_credential_reload_config instance that this argument corresponds to. - context is a pointer to a wrapped language implementation of this grpc_tls_credential_reload_arg instance. - destroy_context is a pointer to a caller-provided method that cleans up any data associated with the context pointer. It is used for experimental purposes for now and subject to change."],["grpc_tls_credential_reload_config",""],["grpc_tls_credentials_options",""],["grpc_tls_error_details",""],["grpc_tls_key_materials_config",""],["grpc_tls_server_authorization_check_arg","A struct containing all information necessary to schedule/cancel a server authorization check request. - cb and cb_user_data represent a gRPC-provided callback and an argument passed to it. - success will store the result of server authorization check. That is, if success returns a non-zero value, it means the authorization check passes and if returning zero, it means the check fails. - target_name is the name of an endpoint the channel is connecting to. - peer_cert represents a complete certificate chain including both signing and leaf certificates. - status and error_details contain information about errors occurred when a server authorization check request is scheduled/cancelled. - config is a pointer to the unique grpc_tls_server_authorization_check_config instance that this argument corresponds to. - context is a pointer to a wrapped language implementation of this grpc_tls_server_authorization_check_arg instance. - destroy_context is a pointer to a caller-provided method that cleans up any data associated with the context pointer. It is used for experimental purpose for now and subject to change."],["grpc_tls_server_authorization_check_config",""],["grpcwrap_batch_context",""],["grpcwrap_batch_context__bindgen_ty_1",""],["grpcwrap_batch_context__bindgen_ty_2",""],["grpcwrap_request_call_context",""],["verify_peer_options","Deprecated in favor of grpc_ssl_verify_peer_options. It will be removed after all of its call sites are migrated to grpc_ssl_verify_peer_options. Object that holds additional peer-verification options on a secure channel."]],"type":[["gpr_atm",""],["gpr_log_func",""],["gpr_thd_id",""],["grpc_credentials_plugin_metadata_cb","Callback function to be called by the metadata credentials plugin implementation when the metadata is ready. - user_data is the opaque pointer that was passed in the get_metadata method of the grpc_metadata_credentials_plugin (see below). - creds_md is an array of credentials metadata produced by the plugin. It may be set to NULL in case of an error. - num_creds_md is the number of items in the creds_md array. - status must be GRPC_STATUS_OK in case of success or another specific error code otherwise. - error_details contains details about the error if any. In case of success it should be NULL and will be otherwise ignored."],["grpc_process_auth_metadata_done_cb","Callback function that is called when the metadata processing is done. - Consumed metadata will be removed from the set of metadata available on the call. consumed_md may be NULL if no metadata has been consumed. - Response metadata will be set on the response. response_md may be NULL. - status is GRPC_STATUS_OK for success or a specific status for an error. Common error status for auth metadata processing is either GRPC_STATUS_UNAUTHENTICATED in case of an authentication failure or GRPC_STATUS PERMISSION_DENIED in case of an authorization failure. - error_details gives details about the error. May be NULL."],["grpc_ssl_roots_override_callback","Callback for getting the SSL roots override from the application. In case of success, *pem_roots_certs must be set to a NULL terminated string containing the list of PEM encoded root certificates. The ownership is passed to the core and freed (laster by the core) with gpr_free. If this function fails and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH environment is set to a valid path, it will override the roots specified this func"],["grpc_ssl_server_certificate_config_callback","Callback to retrieve updated SSL server certificates, private keys, and trusted CAs (for client authentication). - user_data parameter, if not NULL, contains opaque data to be used by the callback. - Use grpc_ssl_server_certificate_config_create to create the config. - The caller assumes ownership of the config."],["grpc_tls_on_credential_reload_done_cb","A callback function provided by gRPC to handle the result of credential reload. It is used when schedule API is implemented asynchronously and serves to bring the control back to grpc C core. It is used for experimental purpose for now and subject to change."],["grpc_tls_on_server_authorization_check_done_cb","callback function provided by gRPC used to handle the result of server authorization check. It is used when schedule API is implemented asynchronously, and serves to bring the control back to gRPC C core. It is used for experimental purpose for now and subject to change."]],"union":[["grpc_arg_grpc_arg_value",""],["grpc_byte_buffer_grpc_byte_buffer_data",""],["grpc_byte_buffer_reader_grpc_byte_buffer_reader_current","Different current objects correspond to different types of byte buffers"],["grpc_op_grpc_op_data",""],["grpc_slice_grpc_slice_data",""]]});