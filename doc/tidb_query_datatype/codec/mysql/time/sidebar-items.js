initSidebarItems({"constant":[["COMPLETE_COMPONENTS_LEN",""],["MAX_TIMESTAMP",""],["MICRO_WIDTH",""],["MIN_TIMESTAMP",""],["MONTH_NAMES",""],["MONTH_NAMES_ABBR",""]],"enum":[["TimeType",""],["Tz","A time zone represented by either offset (i.e. +8) or name (i.e. Asia/Shanghai). In addition, local time zone is also valid."]],"fn":[["chrono_datetime",""],["chrono_naive_datetime",""],["handle_invalid_date",""],["handle_zero_date",""],["handle_zero_in_date",""],["is_leap_year",""],["last_day_of_month",""],["round_components","Round each component."],["round_frac","Round `frac` with `fsp`, return if there is a carry and the result. NOTE: we assume that `frac` is less than `100_000_000` and `fsp` is valid."]],"mod":[["extension",""],["parser",""],["tz",""],["weekmode",""]],"struct":[["Time",""],["TimeArgs","A validator that verify each field for the `Time` NOTE: It's inappropriate to construct `Time` first and then verify it. Because `Time` uses `bitfield`, the range of each field is quite narrow. For example, the size of `month` field is 5 bits. If we get a value 16 for `month` and set it, we will got 0 (16 % 16 == 0) instead 16 which is definitely an invalid value. So we need a larger range for validation."]],"trait":[["TimeDatumPayloadChunkEncoder",""],["TimeDecoder",""],["TimeEncoder","Time Encoder for Chunk format"]]});