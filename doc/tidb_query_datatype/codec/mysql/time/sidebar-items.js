initSidebarItems({"constant":[["COMPLETE_COMPONENTS_LEN",""],["MAX_TIMESTAMP",""],["MICRO_WIDTH",""],["MIN_TIMESTAMP",""],["MONTH_NAMES",""],["MONTH_NAMES_ABBR",""]],"enum":[["TimeType",""],["Tz","A time zone represented by either offset (i.e. +8) or name (i.e. Asia/Shanghai). In addition, local time zone is also valid."]],"fn":[["chrono_datetime",""],["chrono_naive_datetime",""],["handle_invalid_date",""],["handle_zero_date",""],["handle_zero_in_date",""],["is_leap_year",""],["last_day_of_month",""],["round_components","Round each component. `ignore let mut parts = [2019, 12, 1, 23, 59, 59, 1000000]; round_components(&mut parts); assert_eq!([2019, 12, 2, 0, 0, 0, 0], parts); ` When year, month or day is zero, there can not have a carry. e.g.: `\"1998-11-00 23:59:59.999\" (fsp = 2, round = true)`, in `hms` it contains a carry, however, the `day` is 0, which is invalid in `MySQL`. When thoese cases encountered, return None."],["round_frac","Round `frac` with `fsp`, return if there is a carry and the result. NOTE: we assume that `frac` is less than `100_000_000` and `fsp` is valid. `ignore assert_eq!(123460, round_frac(123456, 5)); assert_eq!(1_000_000, round_frac(999999, 5)); assert_eq!(1230, round_frac(1234, 5)); // .001234, fsp = 5 => .001230 `"]],"mod":[["extension",""],["parser",""],["tz",""],["weekmode",""]],"struct":[["Time",""],["TimeArgs","A validator that verify each field for the `Time` NOTE: It's inappropriate to construct `Time` first and then verify it. Because `Time` uses `bitfield`, the range of each field is quite narrow. For example, the size of `month` field is 5 bits. If we get a value 16 for `month` and set it, we will got 0 (16 % 16 == 0) instead 16 which is definitely an invalid value. So we need a larger range for validation."]],"trait":[["TimeDatumPayloadChunkEncoder",""],["TimeDecoder",""],["TimeEncoder","Time Encoder for Chunk format"]]});